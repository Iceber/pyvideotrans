# run again.  Do not edit this file unless you know what you are doing.

import json
import re
from pathlib import Path

from PySide6 import QtCore, QtWidgets
from PySide6.QtCore import QTimer
from PySide6.QtGui import Qt, QFontDatabase, QColor
from PySide6.QtWidgets import QFileDialog, QFontDialog, QColorDialog

from videotrans.configure import config
from videotrans.configure.config import tr


class Ui_setini(object):
    def _show_font_dialog(self):
        default_font = QFontDatabase.systemFont(QFontDatabase.GeneralFont)
        dialog = QFontDialog(default_font, self)
        if dialog.exec():
            font = dialog.selectedFont()
            font_name = font.family()
            font_size = font.pointSize()
            self.fontsize_lineedit.setText(str(font_size))
            self.fontname_lineedit.setText(font_name)

    def _qcolor_to_ass_color(self, color, type='fc'):
        # 获取颜色的 RGB 值
        r = color.red()
        g = color.green()
        b = color.blue()
        if type in ['bg', 'bd']:
            return f"&H80{b:02X}{g:02X}{r:02X}".upper()
        # 将 RGBA 转换为 ASS 的颜色格式 &HBBGGRR
        return f"&H{b:02X}{g:02X}{r:02X}".upper()

    def set_fontcolor(self):

        fontcolor = QColor(re.sub(r'&H', '#', self.fontcolor_lineedit.text(), re.I))  # 默认颜色
        dialog = QColorDialog(fontcolor, self)
        color = dialog.getColor()
        if color.isValid():
            self.fontcolor_lineedit.setText(self._qcolor_to_ass_color(color, type='fc'))

    def set_fontbordercolor(self):

        fontbordercolor = QColor(re.sub(r'&H', '#', self.fontbordercolor_lineedit.text().upper(), re.I))  # 默认颜色
        dialog = QColorDialog(fontbordercolor, self)
        dialog.setOption(QColorDialog.ShowAlphaChannel, True)  # 启用透明度选择
        color = dialog.getColor()
        if color.isValid():
            self.fontbordercolor_lineedit.setText(self._qcolor_to_ass_color(color, type='bd'))

    def set_backgroundcolor(self):

        backgroundcolor = QColor(re.sub(r'&H', '#', self.backgroundcolor_lineedit.text().upper(), re.I))  # 默认颜色
        dialog = QColorDialog(backgroundcolor, self)
        dialog.setOption(QColorDialog.ShowAlphaChannel, True)  # 启用透明度选择
        color = dialog.getColor()
        if color.isValid():
            self.backgroundcolor_lineedit.setText(self._qcolor_to_ass_color(color, type='bg'))

    def set_fontname(self):
        QTimer.singleShot(100, self._show_font_dialog)

    def get_target(self):
        dirname = QFileDialog.getExistingDirectory(self, tr('selectsavedir'), Path.home().as_posix())
        if dirname:
            dirpath = Path(dirname)
            config.HOME_DIR = dirpath.as_posix()
            config.TEMP_HOME = config.HOME_DIR + '/tmp'
            config.settings['homedir'] = config.HOME_DIR
            self.homedir_btn.setText(config.HOME_DIR)
            Path(config.TEMP_HOME).mkdir(parents=True, exist_ok=True)
            with Path(config.ROOT_DIR + "/videotrans/cfg.json").open('w', encoding='utf-8') as f:
                f.write(json.dumps(config.settings, ensure_ascii=False))

    def setupUi(self, setini):
        self.centralwidget = QtWidgets.QWidget(setini)
        self.centralwidget.setObjectName("centralwidget")
        self.has_done = False
        setini.setObjectName("setini")

        setini.setMinimumSize(900, 670)

        self.layout = QtWidgets.QVBoxLayout(setini)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setObjectName("layout")

        scroll_area = QtWidgets.QScrollArea(setini)
        scroll_area.setWidgetResizable(True)
        scroll_area.setAlignment(Qt.AlignmentFlag.AlignTop)

        # 2. 创建一个“容器”QWidget，这个容器将承载你的所有内容
        scroll_content_widget = QtWidgets.QWidget()

        # ultrafast 、 superfast 、 veryfast 、 faster 、 fast 、 medium （默认）、 slow和veryslow
        # 处理速度越来越慢，输出视频压缩率和质量越来越高，视频尺寸也将变小

        # 中文注释 界面ui控制
        self.notices = {
            "common": {
                "lang": "设置软件界面语言，修改后需要重启软件",
                "countdown_sec": "当单个视频翻译时，暂停倒计时秒数",
                "bgm_split_time": "设置分离背景音切割片段，防止视频过长卡死，默认300s",
                "homedir": "用于保存视频分离、字幕配音、字幕翻译等结果的位置，默认软件安装目录下output文件夹",
                "llm_chunk_size": "LLM大模型重新断句时，每次发送多少个字或单词，该值越大断句效果越好，一次性发送全部字幕最佳，但受限于max_token，过长输入可能导致失败",
                "llm_ai_type": "LLM重新断句时使用的AI渠道，目前支持openai或deepseek渠道",
                "gemini_recogn_chunk": "使用gemini识别语音时，每次发送音频切片数，越大效果越好，但失败率会升高",
                "dont_notify": "任务完成或失败后不显示桌面通知",
            },

            "video": {
                "crf": "视频转码时损失控制，0=无损，51=损失最大，默认25",
                "preset": "主要调节编码速度和质量的平衡，有 ultrafast、superfast、veryfast、faster、fast、medium、slow、slower、veryslow 选项，编码速度从快到慢、压缩率从低到高、视频尺寸从大到小。 ",
                "ffmpeg_cmd": "自定义ffmpeg命令参数， 将添加在倒数第二个位置上,例如  -bf 7 -b_ref_mode middle",
                "cuda_decode": "使用cuda解码视频,易出错",
                "video_codec": "采用 libx264 编码或 libx265 编码，264兼容性更好，265压缩比更大清晰度更高"
            },

            "subtitle": {
                "fontsize": "硬字幕字体像素尺寸",
                "fontname": "硬字幕字体名字",
                "fontcolor": "设置字体的颜色，注意&H后的6个字符，每2个字母分别代表 BGR 颜色，即2位蓝色/2位绿色/2位红色，同同时常见的RGB色色颠倒的。",

                "fontbordercolor": "设置字体边框描边颜色(轮廓模式下)，注意&H后的6个字符，每2个字母分别代表 BGR 颜色，即2位蓝色/2位绿色/2位红色，同同时常见的RGB色色颠倒的。",

                "backgroundcolor": "背景色块模式下为背景色，轮廓模式下可能是阴影颜色，可能因播放器支持而不同",
                "subtitle_position": "字幕所处位置，默认底部",
                "marginV": "字幕垂直边距",
                "marginL": "字幕左边距",
                "marginR": "字幕右边距",
                "shadow": "字幕阴影大小",
                "outline": "字幕描边粗细",
                'borderStyle': "轮廓描边是指字幕有文字描边和阴影但无背景色块，背景色块风格则相反"

            },
            "trans": {
                "trans_thread": "传统翻译渠道每次发送字幕行数",
                "aitrans_thread": "AI翻译渠道每次发送字幕行数",
                "translation_wait": "每次翻译后暂停秒数,用于限制请求频率",
                "aisendsrt": "是否在使用AI翻译渠道时发送完整字幕格式内容"
            },
            "dubbing": {
                "dubbing_thread": "同时配音的字幕行数(线程数)",
                "dubbing_wait": "每次配音后暂停秒数,用于限制请求频率",
                "save_segment_audio": "保留每行字幕的配音结果",
                "azure_lines": "Azure TTS批量配音行数，一次多少行",
                "chattts_voice": "ChatTTS 音色值"
            },
            "justify": {
                "remove_silence": "是否移除配音末尾空白",
            },
            "whisper": {
                "vad": "是否在faster-whisper渠道整体识别模式时启用VAD",
                "threshold": "表示音频片段被认为是语音的最低概率。Silero VAD 会为每个音频片段计算语音概率，超过此阈值（threshold）的部分被视为语音，反之视为静音或噪音。默认0.45",
                "min_speech_duration_ms": "如果检测到的语音片段长度小于此值，会被丢弃，目的是去除短暂的非语音噪音。填写数字，单位是ms，默认0ms",
                "max_speech_duration_s": "限制单个语音片段的最大长度。超过此时长时，系统会在持续超过 100 毫秒的静音处分割；若无静音，则在指定时长前强制分割，避免过长片段。填写数字，单位是秒，默认5秒",
                "min_silence_duration_ms": "在语音结束时，需等待的静音时间达到此值后，才会分割出语音片段。填写数字，单位ms，默认140ms",
                "speech_pad_ms": "在检测到的语音片段前后添加缓冲时间，避免切掉边缘语音。填写数字，单位ms，默认0",

                "voice_silence": "Google识别Api静音片段/ms",
                "interval_split": "faster-whisper渠道均等分割模式下分割秒数",
                "model_list": "faster模式和openai模式下的模型名字列表，英文逗号分隔",
                "cuda_com_type": "faster模式时cuda数据类型，int8=消耗资源少，速度快，精度低，float32=消耗资源多，速度慢，精度高，float16适合GPU加速。default默认自选",
                "beam_size": "字幕识别时精度调整，1-5，1=消耗显存最低，5=消耗显存最多",
                "best_of": "字幕识别时精度调整，1-5，1=消耗显存最低，5=消耗显存最多",
                "condition_on_previous_text": "若开启将占用更多GPU，效果也更好，但也容易出现重复或幻觉",
                "zh_hant_s": "强制将识别出的繁体字幕转为简体",
            },
            "prompt_init": {
                "initial_prompt_zh-cn": "发音语言为简体中文时发送给whisper模型的提示词",
                "initial_prompt_zh-tw": "发音语言为繁体中文时发送给whisper模型的提示词",
                "initial_prompt_en": "发音语言为英语时发送给whisper模型的提示词",
                "initial_prompt_fr": "发音语言为法语时发送给whisper模型的提示词",
                "initial_prompt_de": "发音语言为德语时发送给whisper模型的提示词",
                "initial_prompt_ja": "发音语言为日语时发送给whisper模型的提示词",
                "initial_prompt_ko": "发音语言为韩语时发送给whisper模型的提示词",
                "initial_prompt_ru": "发音语言为俄语时发送给whisper模型的提示词",
                "initial_prompt_es": "发音语言为西班牙语时发送给whisper模型的提示词",
                "initial_prompt_th": "发音语言为泰国语时发送给whisper模型的提示词",
                "initial_prompt_it": "发音语言为意大利语时发送给whisper模型的提示词",
                "initial_prompt_pt": "发音语言为葡萄牙语时发送给whisper模型的提示词",
                "initial_prompt_vi": "发音语言为越南语时发送给whisper模型的提示词",
                "initial_prompt_ar": "发音语言为阿拉伯语时发送给whisper模型的提示词",
                "initial_prompt_tr": "发音语言为土耳其语时发送给whisper模型的提示词",
                "initial_prompt_hi": "发音语言为印度语时发送给whisper模型的提示词",
                "initial_prompt_hu": "发音语言为匈牙利语时发送给whisper模型的提示词",
                "initial_prompt_uk": "发音语言为乌克兰语时发送给whisper模型的提示词",
                "initial_prompt_id": "发音语言为印尼语时发送给whisper模型的提示词",
                "initial_prompt_ms": "发音语言为马来西亚语时发送给whisper模型的提示词",
                "initial_prompt_kk": "发音语言为哈萨克语时发送给whisper模型的提示词",
                "initial_prompt_cs": "发音语言为捷克语时发送给whisper模型的提示词",
                "initial_prompt_pl": "发音语言为波兰语时发送给whisper模型的提示词",
                "initial_prompt_nl": "发音语言为荷兰语时发送给whisper模型的提示词",
                "initial_prompt_sv": "发音语言为瑞典语时发送给whisper模型的提示词",
                "initial_prompt_he": "发音语言为瑞典语时发送给whisper模型的提示词",
                "initial_prompt_bn": "发音语言为瑞典语时发送给whisper模型的提示词",
                "initial_prompt_fa": "发音语言为波斯语时发送给whisper模型的提示词",
                "initial_prompt_ur": "发音语言为乌尔都语时发送给whisper模型的提示词",
                "initial_prompt_yue": "发音语言为粤语时发送给whisper模型的提示词",
                "initial_prompt_fil": "发音语言为菲律宾语时发送给whisper模型的提示词"
            }
        }
        # 中文左侧label
        self.titles = {
            "dont_notify": "是否禁用桌面通知",
            "llm_ai_type": "LLM重新断句时的AI渠道",
            "prompt_init": "Whisper模型提示词",
            "gemini_recogn_chunk": "Gemini语音识别时，单次发送音频切片数",
            "llm_chunk_size": "LLM重新断句每批次发送字或单词数",
            "ai302_models": "302.ai翻译模型列表",
            "ai302tts_models": "302.aiTTS模型列表",
            "openairecognapi_model": "OpenAI语音识别模型",
            "chatgpt_model": "ChatGPT模型列表",
            "openaitts_model": "OpenAI TTS模型列表",
            "azure_model": "Azure模型列表",
            "localllm_model": "本地LLM模型列表",
            "zijiehuoshan_model": "字节火山推理接入点",
            "model_list": "faster和openai的模型列表",
            "homedir": "设置输出目录",
            "lang": "软件界面语言",
            "save_segment_audio": "保留每条字幕的配音文件",
            "crf": "视频转码损失控制",
            "cuda_decode": "强制CUDA硬解码视频",
            "preset": "输出视频压缩率",
            "ffmpeg_cmd": "自定义ffmpeg命令参数",
            "video_codec": "264/265编码",
            "remove_silence": "是否移除配音末尾空白",
            "bgm_split_time": "背景音分离切割片段/s",
            "vad": "启用VAD断句",

            "threshold": "语音阈值",
            "max_speech_duration_s": "最长语音持续秒数",
            "min_speech_duration_ms": "最短语音持续毫秒数",
            "min_silence_duration_ms": "静音分割持续毫秒数",
            "speech_pad_ms": "语音填充毫秒数",

            "voice_silence": "Google识别Api静音片段/ms",
            "interval_split": "faster渠道均等分割片段时长/s",
            "trans_thread": "传统翻译渠道每次发送字幕行数",
            "aitrans_thread": "AI翻译渠道每次发送字幕行数",
            "dubbing_thread": "同时配音字幕行数(线程数)",
            "countdown_sec": "暂停倒计时秒数",
            "backaudio_volume": "背景音量变化倍数",
            "loop_backaudio": "是否循环播放背景音",
            "cuda_com_type": "CUDA数据类型",
            "beam_size": "字幕识别准确度beam_size",
            "best_of": "字幕识别准确度best_of",
            "condition_on_previous_text": "是否启用上下文感知",
            "fontsize": "硬字幕字体大小",
            "fontname": "硬字幕字体名字",
            "fontcolor": "硬字幕文字颜色",
            "fontbordercolor": "硬字幕文字边框描边颜色",
            "backgroundcolor": "硬字幕背景色块或阴影色",
            "subtitle_position": "硬字幕位置",
            "marginV": "字幕垂直边距",
            "marginL": "字幕左边距",
            "marginR": "字幕右边距",
            "shadow": "字幕阴影大小",
            "outline": "字幕描边粗细",
            'borderStyle': "轮廓描边模式或背景色块模式",

            "zh_hant_s": "字幕繁体转为简体",
            "azure_lines": "AzureTTS批量行数",
            "chattts_voice": "ChatTTS音色值",
            "translation_wait": "翻译后暂停秒数",
            "dubbing_wait": "配音后暂停秒数"
            ,
            "gemini_model": "Gemini模型列表",

            "aisendsrt": "使用AI翻译渠道时是否发送完整字幕",

            "initial_prompt_zh-cn": "whisper模型简体中文提示词",
            "initial_prompt_zh-tw": "whisper模型繁体中文提示词",
            "initial_prompt_en": "whisper模型英语提示词",
            "initial_prompt_fr": "whisper模型法语提示词",
            "initial_prompt_de": "whisper模型德语提示词",
            "initial_prompt_ja": "whisper模型日语提示词",
            "initial_prompt_ko": "whisper模型韩语提示词",
            "initial_prompt_ru": "whisper模型俄语提示词",
            "initial_prompt_es": "whisper模型西班牙语提示词",
            "initial_prompt_th": "whisper模型泰国语提示词",
            "initial_prompt_it": "whisper模型意大利语提示词",
            "initial_prompt_pt": "whisper模型葡萄牙语提示词",
            "initial_prompt_vi": "whisper模型越南语提示词",
            "initial_prompt_ar": "whisper模型阿拉伯语提示词",
            "initial_prompt_tr": "whisper模型土耳其语提示词",
            "initial_prompt_hi": "whisper模型印度语提示词",
            "initial_prompt_hu": "whisper模型匈牙利语提示词",
            "initial_prompt_uk": "whisper模型乌克兰语提示词",
            "initial_prompt_id": "whisper模型印尼语提示词",
            "initial_prompt_ms": "whisper模型马来语提示词",
            "initial_prompt_kk": "whisper模型哈萨克语提示词",
            "initial_prompt_cs": "whisper模型捷克语提示词",
            "initial_prompt_pl": "whisper模型波兰语提示词",
            "initial_prompt_nl": "whisper模型荷兰语提示词",
            "initial_prompt_bn": "whisper模型孟加拉语提示词",
            "initial_prompt_he": "whisper模型希伯来语提示词",
            "initial_prompt_sv": "whisper模型瑞典语提示词",
            "initial_prompt_fa": "whisper模型波斯语提示词",
            "initial_prompt_ur": "whisper模型乌尔都语提示词",
            "initial_prompt_yue": "whisper模型粤语提示词",
            "initial_prompt_fil": "whisper模型菲律宾语提示词"
        }
        # 中文分区
        self.heads = {
            "common": "通用设置",
            "model": "AI模型列表",
            "video": "视频输出控制",
            "whisper": "faster/openai语音识别调整",
            "justify": "字幕声音画面对齐",
            "subtitle": "硬字幕样式",
            "trans": "字幕翻译调整",
            "dubbing": "配音调整",
            "prompt_init": "Whisper模型提示词"
        }
        if config.defaulelang != 'zh':
            self.notices = {
                "common": {
                    "lang": "Set UI language, requires restart.",
                    "countdown_sec": "Countdown seconds for single video translation pause.",
                    "bgm_split_time": "BGM split time (s) to prevent freezing on long videos. Default: 300s.",
                    "homedir": "Output directory for results (separation, dubbing, subtitles). Default: 'output' folder.",
                    "llm_chunk_size": "LLM chunk size for re-segmentation. Larger is better but limited by max_token.",
                    "llm_ai_type": "AI provider for LLM re-segmentation (e.g., openai, deepseek).",
                    "gemini_recogn_chunk": "Number of audio chunks for Gemini recognition. Larger improves quality but may increase failure rate.",
                    "dont_notify": "Disable desktop notifications for task completion/failure."
                },
                "video": {
                    "crf": "CRF (Constant Rate Factor) for transcoding. 0=lossless, 51=max loss. Default: 25.",
                    "preset": "Encoding preset (speed vs. quality): ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow.",
                    "ffmpeg_cmd": "Custom ffmpeg parameters (e.g., -bf 7 -b_ref_mode middle).",
                    "cuda_decode": "Use CUDA for video decoding (may be unstable).",
                    "video_codec": "Video codec: libx264 (better compatibility) or libx265 (better compression/quality)."
                },
                "subtitle": {
                    "fontsize": "Hardsub font size (pixels).",
                    "fontname": "Hardsub font name.",
                    "fontcolor": "Font color in BGR format (&HBBGGRR).",
                    "fontbordercolor": "Font border color in BGR format (&HBBGGRR).",
                    "backgroundcolor": "Background/shadow color. Varies by mode and player.",
                    "subtitle_position": "Subtitle position. Default: bottom.",
                    "marginV": "Vertical margin.",
                    "marginL": "Left margin.",
                    "marginR": "Right margin.",
                    "shadow": "Shadow size.",
                    "outline": "Outline thickness.",
                    "borderStyle": "Border Style: Outline (text border and shadow) vs. Background (solid block)."
                },
                "trans": {
                    "trans_thread": "Lines per request (traditional translation).",
                    "aitrans_thread": "Lines per request (AI translation).",
                    "translation_wait": "Wait time (s) after each translation to limit request rate.",
                    "aisendsrt": "Send full SRT format content when using AI translation."
                },
                "dubbing": {
                    "dubbing_thread": "Concurrent dubbing lines (threads).",
                    "dubbing_wait": "Wait time (s) after each dubbing to limit request rate.",
                    "save_segment_audio": "Save audio for each subtitle line.",
                    "azure_lines": "Lines per batch for Azure TTS.",
                    "chattts_voice": "ChatTTS voice timbre value."
                },
                "justify": {
                    "remove_silence": "Remove trailing silence from dubbing."
                },
                "whisper": {
                    "vad": "Enable VAD for faster-whisper.",
                    "threshold": "VAD probability threshold for speech detection. Default: 0.45.",
                    "min_speech_duration_ms": "Minimum speech duration (ms) to filter out noise. Default: 0ms.",
                    "max_speech_duration_s": "Maximum speech duration (s) before splitting. Default: 5s.",
                    "min_silence_duration_ms": "Minimum silence duration (ms) to mark end of speech. Default: 140ms.",
                    "speech_pad_ms": "Padding (ms) at the beginning/end of speech segments. Default: 0.",
                    "voice_silence": "Google recognition API silence segment (ms).",
                    "interval_split": "Split interval (s) for faster-whisper equal-split mode.",
                    "model_list": "Model names for faster/openai modes (comma-separated).",
                    "cuda_com_type": "CUDA compute type for faster mode (int8, float16, float32, default).",
                    "beam_size": "Beam size for recognition accuracy (1-5). Higher uses more VRAM.",
                    "best_of": "Best of for recognition accuracy (1-5). Higher uses more VRAM.",
                    "condition_on_previous_text": "Condition on previous text (better but uses more GPU, may cause repetition).",
                    "zh_hant_s": "Force convert Traditional Chinese to Simplified."
                },
                "prompt_init": {
                    "initial_prompt_zh-cn": "Prompt for Whisper when speech is Simplified Chinese.",
                    "initial_prompt_zh-tw": "Prompt for Whisper when speech is Traditional Chinese.",
                    "initial_prompt_en": "Prompt for Whisper when speech is English.",
                    "initial_prompt_fr": "Prompt for Whisper when speech is French.",
                    "initial_prompt_de": "Prompt for Whisper when speech is German.",
                    "initial_prompt_ja": "Prompt for Whisper when speech is Japanese.",
                    "initial_prompt_ko": "Prompt for Whisper when speech is Korean.",
                    "initial_prompt_ru": "Prompt for Whisper when speech is Russian.",
                    "initial_prompt_es": "Prompt for Whisper when speech is Spanish.",
                    "initial_prompt_th": "Prompt for Whisper when speech is Thai.",
                    "initial_prompt_it": "Prompt for Whisper when speech is Italian.",
                    "initial_prompt_pt": "Prompt for Whisper when speech is Portuguese.",
                    "initial_prompt_vi": "Prompt for Whisper when speech is Vietnamese.",
                    "initial_prompt_ar": "Prompt for Whisper when speech is Arabic.",
                    "initial_prompt_tr": "Prompt for Whisper when speech is Turkish.",
                    "initial_prompt_hi": "Prompt for Whisper when speech is Hindi.",
                    "initial_prompt_hu": "Prompt for Whisper when speech is Hungarian.",
                    "initial_prompt_uk": "Prompt for Whisper when speech is Ukrainian.",
                    "initial_prompt_id": "Prompt for Whisper when speech is Indonesian.",
                    "initial_prompt_ms": "Prompt for Whisper when speech is Malaysian.",
                    "initial_prompt_kk": "Prompt for Whisper when speech is Kazakh.",
                    "initial_prompt_cs": "Prompt for Whisper when speech is Czech.",
                    "initial_prompt_pl": "Prompt for Whisper when speech is Polish.",
                    "initial_prompt_nl": "Prompt for Whisper when speech is Dutch.",
                    "initial_prompt_sv": "Prompt for Whisper when speech is Swedish.",
                    "initial_prompt_he": "Prompt for Whisper when speech is Hebrew.",
                    "initial_prompt_bn": "Prompt for Whisper when speech is Bengali.",
                    "initial_prompt_fa": "Prompt for Whisper when speech is Persian.",
                    "initial_prompt_ur": "Prompt for Whisper when speech is Urdu.",
                    "initial_prompt_yue": "Prompt for Whisper when speech is Cantonese.",
                    "initial_prompt_fil": "Prompt for Whisper when speech is Filipino."
                }
            }
            self.titles = {
                "dont_notify": "Disable desktop notifications",
                "llm_ai_type": "AI channel for LLM re-segmentation",
                "prompt_init": "Whisper model prompt",
                "gemini_recogn_chunk": "Gemini speech recognition audio chunk size",
                "llm_chunk_size": "LLM re-segmentation batch size (words)",
                "ai302_models": "302.ai translation model list",
                "ai302tts_models": "302.ai TTS model list",
                "openairecognapi_model": "OpenAI speech recognition model",
                "chatgpt_model": "ChatGPT model list",
                "openaitts_model": "OpenAI TTS model list",
                "azure_model": "Azure model list",
                "localllm_model": "Local LLM model list",
                "zijiehuoshan_model": "ByteDance Volcano Engine endpoint",
                "model_list": "faster & openai model list",
                "homedir": "Set output directory",
                "lang": "Software UI language",
                "save_segment_audio": "Save audio for each subtitle",
                "crf": "Video CRF (Constant Rate Factor)",
                "cuda_decode": "Force CUDA hardware decoding",
                "preset": "Output video compression preset",
                "ffmpeg_cmd": "Custom ffmpeg command arguments",
                "video_codec": "h264/h265 codec",
                "remove_silence": "Remove trailing silence from dubbing",
                "bgm_split_time": "BGM separation clip duration (s)",
                "vad": "Enable VAD segmentation",
                "threshold": "Voice activity threshold",
                "max_speech_duration_s": "Max speech duration (s)",
                "min_speech_duration_ms": "Min speech duration (ms)",
                "min_silence_duration_ms": "Min silence duration (ms)",
                "speech_pad_ms": "Speech padding (ms)",
                "voice_silence": "Google API silence segment (ms)",
                "interval_split": "faster channel split duration (s)",
                "trans_thread": "Traditional translation batch size (lines)",
                "aitrans_thread": "AI translation batch size (lines)",
                "dubbing_thread": "Concurrent dubbing threads",
                "countdown_sec": "Pause countdown (s)",
                "backaudio_volume": "Background audio volume multiplier",
                "loop_backaudio": "Loop background audio",
                "cuda_com_type": "CUDA data type",
                "beam_size": "Subtitle recognition beam_size",
                "best_of": "Subtitle recognition best_of",
                "condition_on_previous_text": "Enable context-aware processing",
                "fontsize": "Hard subtitle font size",
                "fontname": "Hard subtitle font name",
                "fontcolor": "Hard subtitle font color",
                "fontbordercolor": "Hard subtitle border color",
                "backgroundcolor": "Hard subtitle background/shadow color",
                "subtitle_position": "Hard subtitle position",
                "marginV": "Subtitle vertical margin",
                "marginL": "Subtitle left margin",
                "marginR": "Subtitle right margin",
                "shadow": "Subtitle shadow size",
                "outline": "Subtitle outline thickness",
                "borderStyle": "Outline or background box mode",
                "zh_hant_s": "Convert Trad. Chinese to Simp.",
                "azure_lines": "Azure TTS batch size (lines)",
                "chattts_voice": "ChatTTS voice timbre",
                "translation_wait": "Wait after translation (s)",
                "dubbing_wait": "Wait after dubbing (s)",
                "gemini_model": "Gemini model list",
                "aisendsrt": "Send full SRT for AI translation",
                "initial_prompt_zh-cn": "Whisper model prompt (Simp. Chinese)",
                "initial_prompt_zh-tw": "Whisper model prompt (Trad. Chinese)",
                "initial_prompt_en": "Whisper model prompt (English)",
                "initial_prompt_fr": "Whisper model prompt (French)",
                "initial_prompt_de": "Whisper model prompt (German)",
                "initial_prompt_ja": "Whisper model prompt (Japanese)",
                "initial_prompt_ko": "Whisper model prompt (Korean)",
                "initial_prompt_ru": "Whisper model prompt (Russian)",
                "initial_prompt_es": "Whisper model prompt (Spanish)",
                "initial_prompt_th": "Whisper model prompt (Thai)",
                "initial_prompt_it": "Whisper model prompt (Italian)",
                "initial_prompt_pt": "Whisper model prompt (Portuguese)",
                "initial_prompt_vi": "Whisper model prompt (Vietnamese)",
                "initial_prompt_ar": "Whisper model prompt (Arabic)",
                "initial_prompt_tr": "Whisper model prompt (Turkish)",
                "initial_prompt_hi": "Whisper model prompt (Hindi)",
                "initial_prompt_hu": "Whisper model prompt (Hungarian)",
                "initial_prompt_uk": "Whisper model prompt (Ukrainian)",
                "initial_prompt_id": "Whisper model prompt (Indonesian)",
                "initial_prompt_ms": "Whisper model prompt (Malay)",
                "initial_prompt_kk": "Whisper model prompt (Kazakh)",
                "initial_prompt_cs": "Whisper model prompt (Czech)",
                "initial_prompt_pl": "Whisper model prompt (Polish)",
                "initial_prompt_nl": "Whisper model prompt (Dutch)",
                "initial_prompt_bn": "Whisper model prompt (Bengali)",
                "initial_prompt_he": "Whisper model prompt (Hebrew)",
                "initial_prompt_sv": "Whisper model prompt (Swedish)",
                "initial_prompt_fa": "Whisper model prompt (Persian)",
                "initial_prompt_ur": "Whisper model prompt (Urdu)",
                "initial_prompt_yue": "Whisper model prompt (Cantonese)",
                "initial_prompt_fil": "Whisper model prompt (Filipino)"
            }
            self.heads = {
                "common": "Common",
                "model": "AI Models",
                "video": "Video Output",
                "whisper": "ASR Settings",
                "justify": "Alignment",
                "subtitle": "Subtitle Style",
                "trans": "Translation",
                "dubbing": "Dubbing",
                "prompt_init": "Whisper Prompt"
            }

        self.alertnotice = {}
        # 界面语言

        label_title = QtWidgets.QLabel()
        label_title.setText(
            tr("Clicking  title on the left will show help"))
        label_title.setObjectName(f"label_head")
        label_title.setAlignment(Qt.AlignCenter)
        label_title.setStyleSheet("""color:#eeeeee;text-align:center;font-size:16px;margin-top:10px""")
        self.layout.addWidget(label_title)

        self.homedir_btn = None
        helptext = tr("show help")

        h1 = QtWidgets.QHBoxLayout(scroll_content_widget)
        v1 = QtWidgets.QVBoxLayout()
        v2 = QtWidgets.QVBoxLayout()
        h1.addLayout(v1)
        h1.addLayout(v2)

        layout_index = 0
        for headkey, item in self.notices.items():
            box = QtWidgets.QWidget()  # 创建新的 QWidget，它将承载你的 QHBoxLayouts
            box.setLayout(QtWidgets.QVBoxLayout())
            label_title = QtWidgets.QLabel()
            label_title.setText('[' + self.heads[headkey] + "↓]")
            label_title.setStyleSheet("""color:#148CD2;font-size:18px;""")
            label_title.setObjectName(f"label_{headkey}")
            box.layout().addWidget(label_title)
            for key, tips_str in item.items():
                self.alertnotice[key] = tips_str
                tmp = QtWidgets.QHBoxLayout()
                tmp_0 = QtWidgets.QPushButton()
                tmp_0.setStyleSheet("""background-color:transparent;""")

                tmp_0.setText(self.titles[key])
                tmp_0.setObjectName(f'btn_{key}')
                tmp_0.setToolTip(helptext)
                tmp_0.setCursor(Qt.PointingHandCursor)
                tmp.addWidget(tmp_0)

                val = str(config.settings.get(key, "")).lower()
                # 是 cuda_com_type
                if key == 'cuda_com_type':
                    cuda_types = ['default', 'auto', 'float32', 'float16', 'int8', 'int16', 'int8_float16',
                                  'int8_float32', 'bfloat16', 'int8_bfloat16']
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems(cuda_types)
                    tmp1.setObjectName(key)
                    if val in cuda_types:
                        tmp1.setCurrentText(val)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                if key == 'llm_ai_type':
                    ai_types = ['openai', 'deepseek']
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems(ai_types)
                    tmp1.setObjectName(key)
                    if val in ai_types:
                        tmp1.setCurrentText(val)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                if key == 'preset':
                    presets = ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'veryslow']
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems(presets)
                    if val in presets:
                        tmp1.setCurrentText(val)
                    tmp1.setObjectName(key)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                if key == 'subtitle_position':
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems(list(config.POSTION_ASS_VK.keys()))
                    # 根据数字1-9获取对应的位置字符串
                    cur_text = config.POSTION_ASS_KV.get(int(val), 'bottom')
                    tmp1.setCurrentText(cur_text)
                    tmp1.setObjectName(key)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                if key == 'borderStyle':
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems([tr("Outline Border"),
                                   tr("Background Block")])
                    # val==1 是0位置，代表轮廓风格，val==3 是1位置，代表背景色
                    tmp1.setCurrentIndex(0 if int(val) == 1 else 1)
                    tmp1.setObjectName(key)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                if key == "lang":
                    tmp1 = QtWidgets.QComboBox()
                    tmp1.addItems(list(config.SUPPORT_LANG.keys()))
                    # val==1 是0位置，代表轮廓风格，val==3 是1位置，代表背景色
                    tmp1.setCurrentText(config.defaulelang)
                    tmp1.setObjectName(key)
                    tmp.addWidget(tmp1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                # 设置家目录按钮
                if key == 'homedir':
                    self.homedir_btn = QtWidgets.QPushButton()
                    self.homedir_btn.setCursor(Qt.PointingHandCursor)
                    self.homedir_btn.setText(val)
                    self.homedir_btn.setToolTip(
                        tr("Click on Set Home Directory to save the result files for video separation, subtitle translation, subtitle dubbing, etc."))
                    self.homedir_btn.clicked.connect(self.get_target)
                    self.homedir_btn.setObjectName(key)
                    tmp.addWidget(self.homedir_btn)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                # 是checkbox
                if val in ['true', 'false']:
                    tmp_1 = QtWidgets.QCheckBox()
                    tmp_1.setChecked(True if val == 'true' else False)
                    tmp_1.setToolTip(tips_str)
                    tmp_1.setObjectName(key)
                    tmp.addWidget(tmp_1)
                    tmp.addStretch(1)
                    box.layout().addLayout(tmp)
                    continue
                # 是 model_list faster-whisper
                if key == 'model_list':
                    tmp_1 = QtWidgets.QPlainTextEdit()
                    tmp_1.setPlainText(val)
                    tmp_1.setToolTip(tips_str)
                    tmp_1.setObjectName(key)
                    tmp.addWidget(tmp_1)
                    box.layout().addLayout(tmp)
                    continue

                # 文本框
                tmp_1 = QtWidgets.QLineEdit()
                tmp_1.setMinimumSize(QtCore.QSize(0, 30))
                tmp_1.setText(val)
                tmp_1.setPlaceholderText(tips_str)
                if key == 'ai302tts_models':
                    tmp_1.setReadOnly(True)
                tmp_1.setToolTip(tips_str)
                tmp_1.setObjectName(key)
                tmp.addWidget(tmp_1)

                # 挂到self上，方便他处修改
                if key == 'fontsize':
                    self.fontsize_lineedit = tmp_1

                # 增加字体控制按钮
                if key == 'fontname':
                    self.fontname_lineedit = tmp_1
                    self.fontname_btn = QtWidgets.QPushButton()
                    self.fontname_btn.setCursor(Qt.PointingHandCursor)
                    self.fontname_btn.setText(tr("Select Font"))
                    self.fontname_btn.clicked.connect(self.set_fontname)
                    tmp.addWidget(self.fontname_btn)
                elif key == 'fontcolor':
                    self.fontcolor_lineedit = tmp_1
                    # 增加字体颜色控制按钮
                    self.fontcolor_btn = QtWidgets.QPushButton()
                    self.fontcolor_btn.setCursor(Qt.PointingHandCursor)
                    self.fontcolor_btn.setText(tr("Select Font Color"))
                    self.fontcolor_btn.clicked.connect(self.set_fontcolor)
                    tmp.addWidget(self.fontcolor_btn)
                elif key == 'fontbordercolor':
                    self.fontbordercolor_lineedit = tmp_1
                    # 增加边框颜色控制按钮
                    self.fontbordercolor_btn = QtWidgets.QPushButton()
                    self.fontbordercolor_btn.setCursor(Qt.PointingHandCursor)
                    self.fontbordercolor_btn.setText(
                        tr("Select Font outline color"))
                    self.fontbordercolor_btn.clicked.connect(self.set_fontbordercolor)
                    tmp.addWidget(self.fontbordercolor_btn)
                elif key == 'backgroundcolor':
                    self.backgroundcolor_lineedit = tmp_1
                    # 增加边框颜色控制按钮
                    self.backgroundcolor_btn = QtWidgets.QPushButton()
                    self.backgroundcolor_btn.setCursor(Qt.PointingHandCursor)
                    self.backgroundcolor_btn.setText(
                        tr("Select Subtitle Background Block"))
                    self.backgroundcolor_btn.clicked.connect(self.set_backgroundcolor)
                    tmp.addWidget(self.backgroundcolor_btn)

                box.layout().addLayout(tmp)
            if layout_index % 2 == 0:
                v1.addWidget(box)
            else:
                v2.addWidget(box)
            layout_index += 1

        v1.addStretch()
        v2.addStretch()
        scroll_area.setWidget(scroll_content_widget)

        self.layout.addWidget(scroll_area)

        self.set_ok = QtWidgets.QPushButton(setini)

        self.set_ok.setMinimumSize(QtCore.QSize(0, 35))
        self.set_ok.setObjectName("set_ok")
        self.set_ok.setCursor(Qt.PointingHandCursor)
        self.set_ok.setStyleSheet("""color:#ff0""")
        self.layout.addWidget(self.set_ok)

        self.retranslateUi(setini)
        QtCore.QMetaObject.connectSlotsByName(setini)

    def update_ui(self):
        obj=self.findChild(QtWidgets.QComboBox,'lang')
        current_text=obj.currentText()
        _support={}
        for it in Path(f'{config.ROOT_DIR}/videotrans/language').glob('*.json'):
            if it.stat().st_size > 0:
                _support[it.stem] = it.as_posix()
        # 有变化时
        if _support and _support.keys()!=config.SUPPORT_LANG.keys():
            config.SUPPORT_LANG=_support
            obj.clear()
            obj.addItems(list(_support.keys()))
            if current_text in _support:
                obj.setCurrentText(current_text)



    def retranslateUi(self, setini):
        setini.setWindowTitle(tr("Options"))
        self.set_ok.setText(tr("Save and Close"))

